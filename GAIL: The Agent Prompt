GAIL: System Message(GAL) and User Message(I) 
 -> G: Goal : Define what you want to achieve. Example: “Find the list of files and summarize their contents.”
 -> A: Action : Specify how the system or agent should proceed. Example: “Use listFiles() first, then call readFile() if needed.”
 -> I: Information : Provide context, data, or constraints the model needs. Example: “The files are in the current working directory.”
 -> L: Language : Set the tone, style, or format of the response. Example: “Always respond in JSON with toolName and args.”

=============================================================================AI-Agent Tool Descriptions and Naming============================================================================================

-> When developing an agentic AI system, one of the most critical aspects is ensuring that the agent understands the tools it has access to.
-> Example: Java Source Documentation Agent
   -> Imagine we are building an AI agent that scans through all Java files in a src/ directory and automatically generates corresponding documentation files in a docs/ directory. This agent will need to:
   -> List Java files in the src/ directory.
   -> Read the content of each Java file.
   -> Write documentation files in the docs/ directory.
-> Since file operations are straightforward for humans but ambiguous for an AI without context, we must clearly define these tools so the agent knows how to use them effectively.
Step 1: Human Tool Definition
     -> For a human developer, a simple Java method might look like this:
        public List<String> listJavaFiles() {
            /**
             * Returns a list of all Java files in the src/ directory.
             */
            File srcDir = new File("src");
            return Arrays.stream(srcDir.listFiles())
                    .filter(file -> file.getName().endsWith(".java"))
                    .map(File::getName)
                    .collect(Collectors.toList());
        }
     -> This provides a method that retrieves all Java files in the src/ directory, but for an AI system, we need a more structured way to describe it.
Step 2: Why This Isn’t Enough for AI
     -> For an AI agent, just having raw code is not enough.
        -> The AI does not automatically know when or why to use this tool.
        -> It doesn’t understand the input/output contract unless we explicitly define it.
        -> File operations are trivial to humans but ambiguous to AI without structured metadata.

Step 3: Structured Tool Definition for AI
-> Instead of only Java code, we need to describe tools in a structured format (like JSON schemas or declarative metadata) so the AI knows name of the tool, description of what it does, input it requires and output it produces.
-> Example (structured description): a tool that reads a file should specify that it expects a filePath parameter of type string. JSON Schema allows us to express this in a standardized way:
    {
      "toolName": "readFile",
      "description": "Reads the content of a specified file.",
      "parameters": {
        "type": "object",
        "properties": {
          "filePath": { "type": "string" }
        },
        "required": ["filePath"]
      }
    }
-> Similarly, a tool for writing documentation should define that it requires a fileName and content:
    {
      "toolName": "writeDocFile",
      "description": "Writes a documentation file to the docs/ directory.",
      "parameters": {
        "type": "object",
        "properties": {
          "fileName": { "type": "string" },
          "content": { "type": "string" }
        },
        "required": ["fileName", "content"]
      }
    }
-> By providing a JSON Schema for each tool:
   -> The AI can Recognize the tool’s purpose.
   -> The AI / Environment interface can validate input parameters before execution.
-> why JSON schema? 
   -> JSON Schema is a well-known format for defining APIs, making it a natural choice for AI agents as well.
-> Now, the AI agent can clearly reason “If I need to work with source files, I should call listJavaFiles() first.”
-> For multiple parameter: 
-> When humans call a Java method with multiple parameters, we’re fine writing something like.
   -> generateDocs(String fileName, String author, boolean overwrite)
-> But for an AI agent, we don’t want it to produce a comma-separated parameter list. 
   -> Instead of this ❌ (ambiguous, order-dependent):
      {
        "toolName": "generateDocs",
        "args": ["UserService.java", "Vinay", true]
      }
   -> We prefer ✅ (clear, self-describing):
      {
        "toolName": "generateDocs",
        "args": {
          "fileName": "UserService.java",
          "author": "Vinay",
          "overwrite": true
        }
      }
   -> For a tool generateDocs(fileName, author, overwrite) we might describe the schema like this:
      {
        "toolName": "generateDocs",
        "description": "Generates documentation for a given Java file.",
        "argsSchema": {
          "type": "object",
          "properties": {
            "fileName": {
              "type": "string",
              "description": "Name of the Java source file"
            },
            "author": {
              "type": "string",
              "description": "The name of the author to include in the documentation"
            },
            "overwrite": {
              "type": "boolean",
              "description": "If true, overwrite existing documentation"
            }
          },
          "required": ["fileName"]
        }
      }
      -> Here:
        -> argsSchema clearly says “args is an object”.
        -> Each parameter is defined inside it with type + description.
        -> Required vs optional parameters are explicitly marked.
-> Now if we want the LLM (or a config file) to describe tools in JSON, then we need a way to parse JSON → Tool object. Here’s a simplified Tool class with a static method fromJson using Jackson:
   package com.example.agent;
   
   import com.fasterxml.jackson.databind.ObjectMapper;
   
   import java.io.IOException;
   import java.util.Map;
   
   public class Tool {
       private String toolName;
       private String description;
       private Map<String, Object> argsSchema; // simple schema for arguments
   
       // Default constructor for Jackson
       public Tool() {}
   
       public Tool(String toolName, String description, Map<String, Object> argsSchema) {
           this.toolName = toolName;
           this.description = description;
           this.argsSchema = argsSchema;
       }
   
       public String getToolName() {
           return toolName;
       }
   
       public String getDescription() {
           return description;
       }
   
       public Map<String, Object> getArgsSchema() {
           return argsSchema;
       }
   
       @Override
       public String toString() {
           return "Tool{" +
                   "toolName='" + toolName + '\'' +
                   ", description='" + description + '\'' +
                   ", argsSchema=" + argsSchema +
                   '}';
       }
   
       /**
        * Creates a Tool object from a JSON string.
        */
       public static Tool fromJson(String json) throws IOException {
           ObjectMapper mapper = new ObjectMapper();
           return mapper.readValue(json, Tool.class);
       }
   }

















